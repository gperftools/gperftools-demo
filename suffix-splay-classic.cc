// -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil -*-
/* This is a version of a splay tree that performs insertions in a
 * "classic" bottom-up way and it does parent pointers. The meat of
 * insertion and splaying is 100% generated by Gemini. I gave it only
 * little guidance to "inline" double rotations and to improve
 * top-down phase of the insertion (it had some duplicate comparison
 * at the very bottom). Intention to have it is to compare performance
 * and depth stats with my "advanced" top-down implementation.
 */
// #undef NDEBUG
#include <algorithm>
#include <optional>
#include <string>
#include <string_view>

#include <assert.h>
#include <stdio.h>

#include "demo-helper.h"

// Node struct updated with a parent pointer and a constructor.
struct Node {
  std::string_view value;
  Node* parent;
  Node* left;
  Node* right;

  // Constructor for easier node creation.
  Node(std::string_view val, Node* p)
      : value(val), parent(p), left(nullptr), right(nullptr) {}
};

namespace {

// --- Rotation Helpers ---
// Single rotations are used only for the Zig case (parent is the root).
void RightRotate(Node* p);
void LeftRotate(Node* p);

// Optimized double rotation helpers that inline two single rotations.
void RotateZigZigLeftLeft(Node* g);
void RotateZigZigRightRight(Node* g);
void RotateZigZagLeftRight(Node* g);
void RotateZigZagRightLeft(Node* g);


// --- Splay and Insert Logic ---

// Splays the given node 'x' up to the root of the tree.
void Splay(Node* x) {
  while (x->parent) {
    Node* p = x->parent;
    Node* g = p->parent;

    if (!g) {
      // Zig case: Parent is the root.
      if (p->left == x) {
        RightRotate(p);
      } else {
        LeftRotate(p);
      }
    } else {
      // Zig-Zig or Zig-Zag cases are handled by optimized helpers.
      if (g->left == p) {
        if (p->left == x) {
          RotateZigZigLeftLeft(g);
        } else {
          RotateZigZagLeftRight(g);
        }
      } else {  // g->right == p
        if (p->right == x) {
          RotateZigZigRightRight(g);
        } else {
          RotateZigZagRightLeft(g);
        }
      }
    }
  }
}

// Inserts a value, assuming it does not already exist in the tree.
// The root is passed by reference.
void Insert(Node*& root, std::string_view value) {
  // --- Phase 1: Find the insertion point using a pointer-to-pointer ---
  Node** link = &root;
  Node* parent = nullptr;

  while (*link) {
    parent = *link;
    if (value < parent->value) {
      link = &parent->left;
    } else {
      link = &parent->right;
    }
  }

  // --- Phase 2: Create, link, and splay the new node ---
  // 'parent' is the correct parent for the new node.
  // 'link' points to the parent's child pointer that is currently null.
  Node* new_node = new Node(value, parent);
  *link = new_node;

  Splay(new_node);
  root = new_node;  // The new node is now the root.
}


// --- Implementations for rotation helpers ---

void RightRotate(Node* p) {
  Node* x = p->left;
  Node* grandparent = p->parent;
  if (grandparent) {
    if (grandparent->left == p) {
      grandparent->left = x;
    } else {
      grandparent->right = x;
    }
  }
  if (x) x->parent = grandparent;
  p->parent = x;
  if (x && x->right) {
    x->right->parent = p;
  }
  p->left = (x ? x->right : nullptr);
  if (x) x->right = p;
}

void LeftRotate(Node* p) {
  Node* x = p->right;
  Node* grandparent = p->parent;
  if (grandparent) {
    if (grandparent->left == p) {
      grandparent->left = x;
    } else {
      grandparent->right = x;
    }
  }
  if (x) x->parent = grandparent;
  p->parent = x;
  if (x && x->left) {
    x->left->parent = p;
  }
  p->right = (x ? x->left : nullptr);
  if (x) x->left = p;
}

void RotateZigZigLeftLeft(Node* g) {
  Node* p = g->left;
  Node* x = p->left;
  Node* const gg = g->parent;

  g->left = p->right;
  if (g->left) g->left->parent = g;

  p->left = x->right;
  if (p->left) p->left->parent = p;

  p->right = g;
  g->parent = p;

  x->right = p;
  p->parent = x;

  x->parent = gg;
  if (gg) {
    if (gg->left == g) {
      gg->left = x;
    } else {
      gg->right = x;
    }
  }
}

void RotateZigZigRightRight(Node* g) {
  Node* p = g->right;
  Node* x = p->right;
  Node* const gg = g->parent;

  g->right = p->left;
  if (g->right) g->right->parent = g;

  p->right = x->left;
  if (p->right) p->right->parent = p;

  p->left = g;
  g->parent = p;

  x->left = p;
  p->parent = x;

  x->parent = gg;
  if (gg) {
    if (gg->left == g) {
      gg->left = x;
    } else {
      gg->right = x;
    }
  }
}

void RotateZigZagLeftRight(Node* g) {
  Node* p = g->left;
  Node* x = p->right;
  Node* const gg = g->parent;

  p->right = x->left;
  if (p->right) p->right->parent = p;

  g->left = x->right;
  if (g->left) g->left->parent = g;

  x->left = p;
  p->parent = x;

  x->right = g;
  g->parent = x;

  x->parent = gg;
  if (gg) {
    if (gg->left == g) {
      gg->left = x;
    } else {
      gg->right = x;
    }
  }
}

void RotateZigZagRightLeft(Node* g) {
  Node* p = g->right;
  Node* x = p->left;
  Node* const gg = g->parent;

  p->left = x->right;
  if (p->left) p->left->parent = p;

  g->right = x->left;
  if (g->right) g->right->parent = g;

  x->right = p;
  p->parent = x;

  x->left = g;
  g->parent = x;

  x->parent = gg;
  if (gg) {
    if (gg->left == g) {
      gg->left = x;
    } else {
      gg->right = x;
    }
  }
}

}  // anonymous namespace

struct SplayTree {
  Node* root = nullptr;

  ~SplayTree() {
    Clear();
  }

  void InsertBottomUp(std::string_view value) {
    Insert(root, value);
  }

  // We find smallest node that is >= than given string, or nullptr if
  // everything is smaller than str.
  const Node* LowerBound(std::string_view str) {
    const Node* node = root;

    const Node* best = (node && node->value >= str) ? node : nullptr;
    while (node) {
      if (node->value < str) {
        node = node->right;
      } else {
        best = node;
        node = node->left;
      }
    }
    return best;
  }

  void Validate(bool print_stats) {
    struct Checker {
      std::optional<std::string_view> prev_seen;
      size_t total_height = 0;
      size_t node_count = 0;

      int Rec(const Node* node, int depth) {
        if (!node) {
          return 0;
        }

        total_height += depth;
        node_count += 1;
        int left_height = Rec(node->left, depth + 1);

        if (prev_seen.has_value()) {
          assert(node->value > *prev_seen);
          if (node->value <= *prev_seen) {
            abort();
          }
        }
        prev_seen = node->value;

        int right_height = Rec(node->right, depth + 1);

        return std::max<int>(left_height, right_height) + 1;
      }
    };

    Checker checker;
    int max_height = checker.Rec(root, 1);

    if (print_stats) {
      printf("total node count: %zu, average depth: %g, max_height: %d\n",
             checker.node_count,
             static_cast<double>(checker.total_height) / checker.node_count,
             max_height);
    }
  }

  void Clear() {
    // Note, recursion is potentially unsafe here, but this code is
    // not pretending to be production, so lets keep it uncomplicated.
    struct Deleter {
      size_t total_deleted = 0;
      void Rec(Node* n) {
        if (n == nullptr) {
          return;
        }
        Rec(n->left);
        Node* r = n->right;
        delete n;
        total_deleted++;
        Rec(r);
      }
    };

    Deleter d;
    d.Rec(root);
    root = nullptr;
#ifndef NDEBUG
    printf("total_deleted: %zu\n", d.total_deleted);
#endif
    (void)d.total_deleted;
  }
};

int main(int argc, char** argv) {
  SplayTree locations; // Note, we want this destructor to run after
                       // we've dumped heap sample

  auto sampling_cleanup = MaybeSetupHeapSampling(argc, argv);
  std::string s = ReadRomanHistoryText();

  AtomicFlag stop_req;
  auto sigint_cleanup = SignalHelper::OnSIGINT(&stop_req);

  for (int pos = s.size() - 1; pos >= 0; pos--) {
    locations.InsertBottomUp(std::string_view{s}.substr(pos));
    if (stop_req) {
      fprintf(stderr, "interrupted insertions by seeing SIGINT\n");
      break;
    }
#ifndef NDEBUG
    size_t num_inserted = s.size() - pos;
    // We want to validate often when we're at small tree, but
    // otherwise avoid O(N^2) blowup in debug builds.
    if (num_inserted < 128 || (num_inserted & (num_inserted - 1)) == 0) {
      locations.Validate(false);
      printf("inserted %zu suffixes so far\n", num_inserted);
    }
#endif
  }

#ifndef NDEBUG
  locations.Validate(true);
#endif

  const Node* it = locations.LowerBound("the Roman Empire");
  assert(it);

  size_t off = it->value.data() - s.data();
  printf("off = %zu\n", off);

  printf("context of last(ish) occurrence of 'the Roman Empire':\n");
  PrintOccurenceContext(s, off);
}
